
plugins {
    id 'maven-publish'
    id 'com.android.library'
}

//afterEvaluate {
//    publishing {
//        publications {
//            // 定义一个名为 Production 的发布
//            release(MavenPublication) {
//
//                groupId = "com.github.chenzhizzz"
//                artifactId = "XPopup"
//                version  = "2.10.13"
//
////             必须有这个 否则不会上传AAR包
//                 //afterEvaluate { artifact(tasks.getByName("bundleReleaseAar")) }
//                // 上传source，这样使用方可以看到方法注释
//                // artifact generateSourcesJar
//                artifact "$buildDir/outputs/aar/${project.getName()}.aar" //要上传的aar路径
////                afterEvaluate {
////                    from components.java
////                }
//            }
//
//
//        }
//    }
//}

// 增加上传源码的task
//task sourceJar(type: Jar) {
//    from android.sourceSets.main.java.srcDirs
//    archiveClassifier = "sources"
//}


//
//task makeJar(type: Copy) {
//
////删除存在的
//
//    delete 'build/libs/thermelcontrol.jar'
//
////设置拷贝的文件
//
//// from('build/intermediates/bundles/release/')
//
//    from('build/intermediates/runtime_library_classes_jar/debug')
//
////打进jar包后的文件目录
//
//    into('build/libs/')
//
////将classes.jar放入build/libs/目录下
//
////include ,exclude参数来设置过滤
//
////（我们只关心classes.jar这个文件）
//
//    include('classes.jar')
//
////重命名
//
//    rename ('classes.jar', 'Xpopup.jar')
//
//}
//
//
//task libraryJar(type: Jar) {
//    archiveClassifier = 'library'
////    from {
////        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
////    }
//    destinationDirectory = file("$buildDir/libs")
//    // 排除不需要的文件，比如R.class和BuildConfig.class
////    exclude '**/R.class', '**/R$*.class', '**/BuildConfig.*'
//}



// 在maven-publish插件的基础使用中是不包含上传aar包的源码。
// 增加上传源码的task，如：
tasks.register("sourceJar", Jar) {
    // 通过 android.sourceSets.main.java.srcDirs 指定的源码，只能识别到 Java 文件，而 kt 文件被忽略了，但 通过查看官方文档可以知道，from 函数是可以指定源码路径的，
    // 所以这里直接把 from 函数的参数替换为 源码路径，如以下代码
    from android.sourceSets.main.java.getSrcDirs() // 源码路径
    archiveClassifier = "sources"
}

//publishing用于配置项目发布相关信息，可以配置的信息有两个：repositories 和 publications
publishing {
    // 配置maven 仓库
    repositories {
        // 本地仓库位于USER_HOME/.m2/repository
        mavenLocal()
//        // 其他maven仓库
//        maven { url uri('/Users/h__d/Desktop/1') }
//        // aliyun镜像仓库
//        maven {
//            // 凭证 访问仓库的 账号和密码
//            credentials {
//                username 'username' // 仓库发布用户名
//                password 'password' // 仓库发布用户密码
//            }
//            // 仓库地址
//            url 'https://maven.aliyun.com/nexus/content/groups/public/'
//        }

    }

    // 配置需要发布的jar的信息，即aar包的信息。publications是一个容器，类型是 PublicationContainer，其可以配置的信息类型是MavenPublication，可以理解成是一个列表集合，
    // 而集合中存储的对象是 MavenPublication，而对象的名称可以由自己随便定义。 所以 publications 也是可以配置多个的，如：release
    publications {
        // 任务名称：release  （名称可以随便定义）比如release表示发布正式包，debug表示snapshot包
        release(MavenPublication) {
            // 上传指定aar包的方式有两种
            // 依赖 bundleReleaseAar 任务，并上传其产出的aar
            afterEvaluate { artifact(tasks.getByName("bundleReleaseAar")) } // 方式一：生成aar包
            // artifact "$buildDir/outputs/aar/${project.name}-release.aar" // 方式二：指定生成的aar路径
//            groupId = "com.github.cncomer"
//            artifactId = "okpermission"
//            version = "1.0.0"

            groupId = "com.github.chenzhizzz"
            artifactId = "XPopup"
            version  = "2.10.03"

            artifact sourceJar
            // 依赖传递
            // 经过基础与上传源码后，是能正常依赖与使用的，但是aar包原本依赖的一下第三方包是不会自动依赖，需要手动添加依赖。
            // 把library中的依赖信息，手动添加到 pom 文件中，就可以完成依赖传递，如下：
            // pom文件中声明依赖，从而传递到使用方，注意需要--no-configuration-cache选项
            pom.withXml {
                def dependenciesNode = asNode().appendNode('dependencies')
                configurations.implementation.allDependencies.each {
                    // 避免出现空节点或 artifactId=unspecified 的节点
                    if (it.group != null && (it.name != null && "unspecified" != it.name) && it.version != null) {
                        println "dependency=${it.toString()}"
                        def dependencyNode = dependenciesNode.appendNode('dependency')
                        dependencyNode.appendNode('groupId', it.group)
                        dependencyNode.appendNode('artifactId', it.name)
                        dependencyNode.appendNode('version', it.version)
                        dependencyNode.appendNode('scope', 'implementation')
                    }
                }
            }
        }
    }
}





android {
    compileSdkVersion 30
    namespace 'com.lxj.xpopup'
    defaultConfig {
        minSdkVersion 19
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'androidx.appcompat:appcompat:1.3.1'
    implementation 'com.google.android.material:material:1.4.0'
    implementation 'androidx.recyclerview:recyclerview:1.2.1'
    implementation 'com.github.li-xiaojun:EasyAdapter:1.2.8'
    implementation 'com.github.bumptech.glide:glide:4.12.0'
    implementation 'com.davemorrissey.labs:subsampling-scale-image-view-androidx:3.10.0'
    annotationProcessor "androidx.lifecycle:lifecycle-compiler:2.3.1"
}
